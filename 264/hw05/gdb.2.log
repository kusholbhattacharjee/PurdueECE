Breakpoint 1 at 0x40078c: file test_calc.c, line 5.
Starting program: /home/shay/a/kbhattac/264/hw05/calc 

Breakpoint 1, main (argc=1, argv=0x7fffffffe3d8) at test_calc.c:5
5		int result = calculate("1", '+', "1");
#0  main (argc=1, argv=0x7fffffffe3d8) at test_calc.c:5
5		int result = calculate("1", '+', "1");
1	#include <stdio.h>
2	#include "calc.h"
3	
4	int main(int argc, char *argv[]) {
5		int result = calculate("1", '+', "1");
6		printf("1 + 1 = %d\n", result);
7	
8		result = calculate("0xa", '+', "3");
9		printf("0xa + 3 = %d\n", result);
10	
main (argc=1, argv=0x7fffffffe3d8) at test_calc.c:8
8		result = calculate("0xa", '+', "3");
calculate (lhs_str=0x400a48 "0xa", operator=43 '+', rhs_str=0x400a46 "3")
    at calc.c:10
10		int lhs_int = _parse_integer(lhs_str);
_parse_integer (s=0x400a48 "0xa") at calc.c:29
29		const char* start = s; // address of first digit after "0x", "0b", or "-"
31		int sign  = 0;   // 1 if positive, -1 if negative
32		_find_sign(&start, &sign);
_find_sign (start=0x7fffffffe270, sign=0x7fffffffe26c) at calc.c:49
49		if(*start[0] == '-') {
54			*sign = 1;   // No minus sign, so mark this as positive
56	}
_parse_integer (s=0x400a48 "0xa") at calc.c:34
34		int base  = 0;   // 10 for decimal, 16 for hexadecimal, 2 for binary
35		_find_base(&start, &base);
_find_base (start=0x7fffffffe270, base=0x7fffffffe268) at calc.c:59
59		if(*start[0] == '0' && *start[1] == 'x') {
$1 = (const char **) 0x7fffffffe270
0x7fffffffe270:	0x48	0x0a	0x40	0x00	0x00	0x00	0x00	0x00
0x7fffffffe270:	0x400a48
$2 = 0x400a48 "0xa"
$3 = 48 '0'
$4 = 73 'I'
$5 = 120 'x'
$6 = 73 'I'
